<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jarvis ‚Äî Mode Voiture (v2 corrig√©)</title>
  <style>
    body{
      font-family:system-ui,Arial,sans-serif;
      margin:16px;
      background:#f5f5f5;
    }
    .card{
      border:1px solid #ddd;
      border-radius:12px;
      padding:14px;
      max-width:820px;
      background:white;
      box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    button{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid #ccc;
      background:#fff;
      cursor:pointer;
      transition:all 0.2s;
    }
    button:hover:not(:disabled){
      background:#f0f0f0;
      transform:translateY(-1px);
    }
    button:disabled{
      opacity:.4;
      cursor:not-allowed;
    }
    textarea{
      width:100%;
      min-height:90px;
      padding:10px;
      border-radius:10px;
      border:1px solid #ccc;
      font-family:monospace;
      font-size:13px;
    }
    .status{
      font-weight:700;
      margin:8px 0;
      padding:8px 12px;
      border-radius:8px;
      display:inline-block;
    }
    .status.idle{background:#e8f5e9;color:#2e7d32;}
    .status.listening{background:#e3f2fd;color:#1565c0;animation:pulse 1.5s infinite;}
    .status.processing{background:#fff3e0;color:#e65100;}
    .status.speaking{background:#f3e5f5;color:#6a1b9a;}
    .status.error{background:#ffebee;color:#c62828;}
    
    @keyframes pulse{
      0%,100%{opacity:1;}
      50%{opacity:0.7;}
    }
    
    .muted{
      opacity:.7;
      font-size:13px;
      line-height:1.4;
    }
    label{
      display:block;
      margin-top:12px;
      margin-bottom:4px;
      font-weight:600;
      font-size:14px;
    }
    .debug-log{
      max-height:120px;
      overflow-y:auto;
      font-size:11px;
      line-height:1.3;
    }
  </style>
</head>

<body>
<h2>üöó Jarvis vocal ‚Äî Mode Voiture (v2)</h2>

<div class="card">
  <div class="row">
    <button id="btnMic">üé§ D√©marrer</button>
    <button id="btnStop" disabled>‚èπ Stop</button>
    <button id="btnSend">‚û°Ô∏è Envoyer</button>
    <button id="btnSpeak" disabled>üîä Relire</button>
    <button id="btnClear">üßπ Effacer</button>
  </div>

  <p class="muted">
    <strong>Version corrig√©e :</strong> machine √† √©tats stricte, pas de boucle infinie, 
    s√©paration claire √©coute/traitement/r√©ponse.
  </p>

  <div class="status idle" id="status">√âtat : IDLE</div>

  <label>üìù Texte reconnu :</label>
  <textarea id="inputText"></textarea>

  <label>üí¨ R√©ponse Jarvis :</label>
  <textarea id="outputText" readonly></textarea>

  <label>üêû Debug (JSON brut) :</label>
  <textarea id="rawText" readonly class="debug-log"></textarea>
</div>

<script>
/* ================= CONFIGURATION ================= */
const CONFIG = {
  webhookUrl: "https://n8n.srv765349.hstgr.cloud/webhook/jarvis",
  
  // D√©lai de silence avant envoi automatique (ms)
  autoSendSilenceMs: 2000,
  
  // D√©lai APR√àS la fin de TTS avant de r√©√©couter (s√©curit√© anti-boucle)
  restartAfterTtsMs: 2500,
  
  // Nombre minimum de caract√®res pour d√©clencher un envoi
  minCharsToSend: 5,
  
  // Mode conversation continue
  continuousMode: true,
  
  // Langue
  lang: "fr-FR"
};

/* ================= MACHINE √Ä √âTATS ================= */
const STATE = {
  IDLE: 'idle',           // Repos, rien en cours
  LISTENING: 'listening', // Micro actif, √©coute utilisateur
  PROCESSING: 'processing', // Envoi + attente r√©ponse
  SPEAKING: 'speaking'    // Lecture TTS de la r√©ponse
};

let currentState = STATE.IDLE;

/* ================= R√âF√âRENCES DOM ================= */
const $ = id => document.getElementById(id);
const btnMic = $("btnMic");
const btnStop = $("btnStop");
const btnSend = $("btnSend");
const btnSpeak = $("btnSpeak");
const btnClear = $("btnClear");
const inputText = $("inputText");
const outputText = $("outputText");
const rawText = $("rawText");
const statusEl = $("status");

/* ================= VARIABLES GLOBALES ================= */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
let silenceTimer = null;

/* ================= GESTION DES √âTATS ================= */
function setState(newState) {
  currentState = newState;
  updateUI();
  console.log(`[STATE] ‚Üí ${newState.toUpperCase()}`);
}

function updateUI() {
  // Mise √† jour visuelle du statut
  statusEl.className = `status ${currentState}`;
  statusEl.textContent = `√âtat : ${currentState.toUpperCase()}`;
  
  // Gestion des boutons
  btnMic.disabled = (currentState !== STATE.IDLE);
  btnStop.disabled = (currentState !== STATE.LISTENING);
  btnSend.disabled = (currentState === STATE.PROCESSING || currentState === STATE.SPEAKING);
  
  // Log visuel
  if (currentState === STATE.IDLE) {
    rawText.value += `\n[${new Date().toLocaleTimeString()}] Retour au repos`;
  }
}

/* ================= GESTION DU TIMER DE SILENCE ================= */
function clearSilenceTimer() {
  if (silenceTimer) {
    clearTimeout(silenceTimer);
    silenceTimer = null;
  }
}

function resetSilenceTimer() {
  clearSilenceTimer();
  silenceTimer = setTimeout(() => {
    console.log("[SILENCE] D√©tect√© ‚Üí envoi automatique");
    stopListeningAndSend();
  }, CONFIG.autoSendSilenceMs);
}

/* ================= RECONNAISSANCE VOCALE ================= */
function initSpeechRecognition() {
  if (!SpeechRecognition) {
    setState(STATE.IDLE);
    statusEl.textContent = "‚ùå Reconnaissance vocale non support√©e";
    statusEl.className = "status error";
    btnMic.disabled = true;
    return false;
  }

  recognition = new SpeechRecognition();
  recognition.lang = CONFIG.lang;
  recognition.interimResults = true;
  recognition.continuous = false; // Important: on g√®re manuellement le red√©marrage

  recognition.onstart = () => {
    console.log("[STT] D√©marr√©");
    setState(STATE.LISTENING);
  };

  recognition.onresult = (event) => {
    let transcript = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      transcript += event.results[i][0].transcript;
    }
    
    inputText.value = transcript.trim();
    
    // R√©initialiser le timer √† chaque nouvelle parole d√©tect√©e
    if (currentState === STATE.LISTENING) {
      resetSilenceTimer();
    }
  };

  recognition.onerror = (event) => {
    console.error("[STT] Erreur:", event.error);
    clearSilenceTimer();
    
    // Ne pas red√©marrer en cas d'erreur r√©seau ou permission
    if (event.error === 'network' || event.error === 'not-allowed') {
      setState(STATE.IDLE);
      statusEl.textContent = `‚ùå Erreur micro: ${event.error}`;
      statusEl.className = "status error";
      return;
    }
    
    // Pour les autres erreurs, retour IDLE et √©ventuellement red√©marrer
    setState(STATE.IDLE);
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 1500);
    }
  };

  recognition.onend = () => {
    console.log("[STT] Arr√™t√©");
    clearSilenceTimer();
    
    // ‚ö†Ô∏è CRUCIAL: Ne red√©marrer QUE si on est en IDLE et en mode continu
    // Cela √©vite de red√©marrer pendant PROCESSING ou SPEAKING
    if (currentState === STATE.LISTENING) {
      setState(STATE.IDLE);
    }
    
    // Red√©marrage automatique UNIQUEMENT si:
    // 1. Mode continu activ√©
    // 2. √âtat actuel est IDLE
    // 3. Pas en train de traiter ou parler
    if (CONFIG.continuousMode && currentState === STATE.IDLE) {
      console.log("[AUTO] Red√©marrage √©coute dans 500ms");
      setTimeout(() => {
        if (currentState === STATE.IDLE) { // Double v√©rification
          startListening();
        }
      }, 500);
    }
  };

  return true;
}

/* ================= CONTR√îLE DE L'√âCOUTE ================= */
function startListening() {
  // Bloquer si pas en IDLE
  if (currentState !== STATE.IDLE) {
    console.log("[STT] Impossible de d√©marrer, √©tat:", currentState);
    return;
  }
  
  clearSilenceTimer();
  
  try {
    recognition.start();
  } catch (e) {
    console.error("[STT] Erreur au d√©marrage:", e);
    // L'API peut lever une erreur si d√©j√† d√©marr√©e
    setState(STATE.IDLE);
  }
}

function stopListeningAndSend() {
  clearSilenceTimer();
  
  // Arr√™ter proprement la reconnaissance
  if (currentState === STATE.LISTENING) {
    try {
      recognition.stop(); // Cela d√©clenchera onend
    } catch (e) {
      console.error("[STT] Erreur √† l'arr√™t:", e);
    }
  }
  
  // Envoyer le texte
  const text = inputText.value.trim();
  if (text.length >= CONFIG.minCharsToSend) {
    sendToWebhook();
  } else {
    console.log("[SEND] Texte trop court, annulation");
    setState(STATE.IDLE);
  }
}

function forceStop() {
  clearSilenceTimer();
  
  if (currentState === STATE.LISTENING) {
    try {
      recognition.stop();
    } catch (e) {
      console.error("[STT] Erreur √† l'arr√™t forc√©:", e);
    }
  }
  
  setState(STATE.IDLE);
}

/* ================= ENVOI AU WEBHOOK ================= */
async function sendToWebhook() {
  const text = inputText.value.trim();
  
  if (!text) {
    console.log("[SEND] Aucun texte √† envoyer");
    setState(STATE.IDLE);
    return;
  }
  
  // Passer en mode PROCESSING (bloque toute autre action)
  setState(STATE.PROCESSING);
  
  outputText.value = "";
  btnSpeak.disabled = true;
  
  console.log("[SEND] Envoi au webhook:", text);
  rawText.value += `\n[${new Date().toLocaleTimeString()}] üì§ "${text}"`;
  
  try {
    const response = await fetch(CONFIG.webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ chatInput: text })
    });
    
    const rawResponse = await response.text();
    rawText.value += `\n[${new Date().toLocaleTimeString()}] üì• ${rawResponse.substring(0, 100)}...`;
    
    // Extraction de la r√©ponse
    let answer = rawResponse;
    try {
      const parsed = JSON.parse(rawResponse);
      answer = extractOutput(parsed) || rawResponse;
    } catch (e) {
      console.log("[PARSE] R√©ponse non-JSON, utilisation brute");
    }
    
    outputText.value = answer;
    btnSpeak.disabled = false;
    
    // Passer en mode SPEAKING et lancer TTS
    speakResponse(answer);
    
  } catch (error) {
    console.error("[SEND] Erreur r√©seau:", error);
    rawText.value += `\n[${new Date().toLocaleTimeString()}] ‚ùå Erreur: ${error.message}`;
    
    setState(STATE.IDLE);
    
    // Red√©marrer automatiquement apr√®s une erreur
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 2000);
    }
  }
}

/* ================= EXTRACTION DE LA R√âPONSE ================= */
function extractOutput(obj) {
  if (!obj || typeof obj !== "object") return null;
  if (typeof obj.output === "string") return obj.output;
  
  for (const key in obj) {
    const result = extractOutput(obj[key]);
    if (result) return result;
  }
  
  return null;
}

/* ================= SYNTH√àSE VOCALE ================= */
function speakResponse(text) {
  if (!text) {
    console.log("[TTS] Pas de texte √† lire");
    setState(STATE.IDLE);
    return;
  }
  
  // Passer en mode SPEAKING (bloque le micro)
  setState(STATE.SPEAKING);
  
  // Annuler toute synth√®se en cours
  speechSynthesis.cancel();
  
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = CONFIG.lang;
  utterance.rate = 1.0;
  utterance.pitch = 1.0;
  
  utterance.onstart = () => {
    console.log("[TTS] D√©but lecture");
  };
  
  utterance.onend = () => {
    console.log("[TTS] Fin lecture");
    
    // ‚úÖ CRUCIAL: Repasser en IDLE AVANT de red√©marrer l'√©coute
    setState(STATE.IDLE);
    
    // Red√©marrage de l'√©coute avec d√©lai de s√©curit√©
    if (CONFIG.continuousMode) {
      console.log(`[AUTO] Red√©marrage √©coute dans ${CONFIG.restartAfterTtsMs}ms`);
      setTimeout(() => {
        // Double v√©rification qu'on est toujours en IDLE
        if (currentState === STATE.IDLE) {
          startListening();
        }
      }, CONFIG.restartAfterTtsMs);
    }
  };
  
  utterance.onerror = (event) => {
    console.error("[TTS] Erreur:", event.error);
    setState(STATE.IDLE);
    
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 2000);
    }
  };
  
  speechSynthesis.speak(utterance);
}

/* ================= BOUTONS UI ================= */
btnMic.onclick = () => {
  console.log("[UI] Bouton D√©marrer");
  startListening();
};

btnStop.onclick = () => {
  console.log("[UI] Bouton Stop");
  forceStop();
};

btnSend.onclick = () => {
  console.log("[UI] Bouton Envoyer");
  sendToWebhook();
};

btnSpeak.onclick = () => {
  console.log("[UI] Bouton Relire");
  speakResponse(outputText.value);
};

btnClear.onclick = () => {
  console.log("[UI] Bouton Effacer");
  inputText.value = "";
  outputText.value = "";
  rawText.value = "";
  btnSpeak.disabled = true;
  setState(STATE.IDLE);
};

/* ================= INITIALISATION ================= */
if (initSpeechRecognition()) {
  console.log("‚úÖ Jarvis initialis√© avec succ√®s");
  rawText.value = `[${new Date().toLocaleTimeString()}] ‚úÖ Syst√®me pr√™t\n`;
} else {
  console.error("‚ùå Impossible d'initialiser la reconnaissance vocale");
}
</script>
</body>
</html>
