<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Jarvis ‚Äî Mode Voiture (v3 fix√©)</title>
  <style>
    body{
      font-family:system-ui,Arial,sans-serif;
      margin:16px;
      background:#f5f5f5;
    }
    .card{
      border:1px solid #ddd;
      border-radius:12px;
      padding:14px;
      max-width:820px;
      background:white;
      box-shadow:0 2px 8px rgba(0,0,0,0.1);
    }
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:12px;
    }
    button{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid #ccc;
      background:#fff;
      cursor:pointer;
      transition:all 0.2s;
    }
    button:hover:not(:disabled){
      background:#f0f0f0;
      transform:translateY(-1px);
    }
    button:disabled{
      opacity:.4;
      cursor:not-allowed;
    }
    textarea{
      width:100%;
      min-height:90px;
      padding:10px;
      border-radius:10px;
      border:1px solid #ccc;
      font-family:monospace;
      font-size:13px;
    }
    .status{
      font-weight:700;
      margin:8px 0;
      padding:8px 12px;
      border-radius:8px;
      display:inline-block;
    }
    .status.idle{background:#e8f5e9;color:#2e7d32;}
    .status.listening{background:#e3f2fd;color:#1565c0;animation:pulse 1.5s infinite;}
    .status.processing{background:#fff3e0;color:#e65100;}
    .status.speaking{background:#f3e5f5;color:#6a1b9a;}
    .status.error{background:#ffebee;color:#c62828;}
    
    @keyframes pulse{
      0%,100%{opacity:1;}
      50%{opacity:0.7;}
    }
    
    .muted{
      opacity:.7;
      font-size:13px;
      line-height:1.4;
    }
    label{
      display:block;
      margin-top:12px;
      margin-bottom:4px;
      font-weight:600;
      font-size:14px;
    }
    .debug-log{
      max-height:120px;
      overflow-y:auto;
      font-size:11px;
      line-height:1.3;
    }
  </style>
</head>

<body>
<h2>üöó Jarvis vocal ‚Äî Mode Voiture (v3)</h2>

<div class="card">
  <div class="row">
    <button id="btnMic">üé§ D√©marrer</button>
    <button id="btnStop" disabled>‚èπ Stop</button>
    <button id="btnSend">‚û°Ô∏è Envoyer</button>
    <button id="btnSpeak" disabled>üîä Relire</button>
    <button id="btnClear">üßπ Effacer</button>
  </div>

  <p class="muted">
    <strong>v3 corrig√©e :</strong> envoi automatique √† la fin de la reconnaissance, 
    gestion robuste des √©tats, pas de boucle infinie.
  </p>

  <div class="status idle" id="status">√âtat : IDLE</div>

  <label>üìù Texte reconnu :</label>
  <textarea id="inputText"></textarea>

  <label>üí¨ R√©ponse Jarvis :</label>
  <textarea id="outputText" readonly></textarea>

  <label>üêû Debug :</label>
  <textarea id="rawText" readonly class="debug-log"></textarea>
</div>

<script>
/* ================= CONFIGURATION ================= */
const CONFIG = {
  webhookUrl: "https://n8n.srv765349.hstgr.cloud/webhook/jarvis",
  
  // Nombre minimum de caract√®res pour envoyer
  minCharsToSend: 5,
  
  // D√©lai APR√àS la fin de TTS avant de r√©√©couter
  restartAfterTtsMs: 2500,
  
  // Mode conversation continue
  continuousMode: true,
  
  // Langue
  lang: "fr-FR"
};

/* ================= MACHINE √Ä √âTATS ================= */
const STATE = {
  IDLE: 'idle',
  LISTENING: 'listening',
  PROCESSING: 'processing',
  SPEAKING: 'speaking'
};

let currentState = STATE.IDLE;

/* ================= R√âF√âRENCES DOM ================= */
const $ = id => document.getElementById(id);
const btnMic = $("btnMic");
const btnStop = $("btnStop");
const btnSend = $("btnSend");
const btnSpeak = $("btnSpeak");
const btnClear = $("btnClear");
const inputText = $("inputText");
const outputText = $("outputText");
const rawText = $("rawText");
const statusEl = $("status");

/* ================= VARIABLES GLOBALES ================= */
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
let recognition = null;
let lastTranscript = ""; // Pour d√©tecter si nouveau texte

/* ================= GESTION DES √âTATS ================= */
function setState(newState) {
  currentState = newState;
  updateUI();
  addLog(`√âtat ‚Üí ${newState.toUpperCase()}`);
}

function updateUI() {
  statusEl.className = `status ${currentState}`;
  statusEl.textContent = `√âtat : ${currentState.toUpperCase()}`;
  
  btnMic.disabled = (currentState !== STATE.IDLE);
  btnStop.disabled = (currentState !== STATE.LISTENING);
  btnSend.disabled = (currentState === STATE.PROCESSING || currentState === STATE.SPEAKING);
}

function addLog(message) {
  const time = new Date().toLocaleTimeString('fr-FR');
  rawText.value += `[${time}] ${message}\n`;
  rawText.scrollTop = rawText.scrollHeight;
  console.log(`[${time}] ${message}`);
}

/* ================= RECONNAISSANCE VOCALE ================= */
function initSpeechRecognition() {
  if (!SpeechRecognition) {
    setState(STATE.IDLE);
    statusEl.textContent = "‚ùå Reconnaissance vocale non support√©e";
    statusEl.className = "status error";
    btnMic.disabled = true;
    return false;
  }

  recognition = new SpeechRecognition();
  recognition.lang = CONFIG.lang;
  recognition.interimResults = true;
  recognition.continuous = false;

  recognition.onstart = () => {
    addLog("üé§ Micro d√©marr√©");
    setState(STATE.LISTENING);
    lastTranscript = "";
  };

  recognition.onresult = (event) => {
    let transcript = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      transcript += event.results[i][0].transcript;
    }
    
    const text = transcript.trim();
    inputText.value = text;
    lastTranscript = text;
    
    addLog(`üìù Texte: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
  };

  recognition.onerror = (event) => {
    addLog(`‚ùå Erreur micro: ${event.error}`);
    
    if (event.error === 'network' || event.error === 'not-allowed') {
      setState(STATE.IDLE);
      statusEl.textContent = `‚ùå Erreur: ${event.error}`;
      statusEl.className = "status error";
      return;
    }
    
    setState(STATE.IDLE);
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 1500);
    }
  };

  recognition.onend = () => {
    addLog("üõë Reconnaissance arr√™t√©e");
    
    // ‚úÖ CORRECTIF PRINCIPAL: Si on a du texte, l'envoyer !
    const text = inputText.value.trim();
    
    if (currentState === STATE.LISTENING && text.length >= CONFIG.minCharsToSend) {
      addLog(`üì§ Envoi automatique: "${text.substring(0, 30)}..."`);
      sendToWebhook();
    } else if (currentState === STATE.LISTENING) {
      // Pas assez de texte, retour IDLE et red√©marrage
      addLog(`‚ö†Ô∏è Texte trop court (${text.length} chars), red√©marrage...`);
      setState(STATE.IDLE);
      
      if (CONFIG.continuousMode) {
        setTimeout(() => {
          if (currentState === STATE.IDLE) {
            startListening();
          }
        }, 500);
      }
    }
  };

  return true;
}

/* ================= CONTR√îLE DE L'√âCOUTE ================= */
function startListening() {
  if (currentState !== STATE.IDLE) {
    addLog(`‚ö†Ô∏è Impossible de d√©marrer (√©tat: ${currentState})`);
    return;
  }
  
  inputText.value = "";
  lastTranscript = "";
  
  try {
    recognition.start();
  } catch (e) {
    addLog(`‚ùå Erreur d√©marrage: ${e.message}`);
    setState(STATE.IDLE);
  }
}

function forceStop() {
  if (currentState === STATE.LISTENING) {
    try {
      recognition.stop(); // onend sera appel√© automatiquement
    } catch (e) {
      addLog(`‚ùå Erreur arr√™t: ${e.message}`);
    }
  }
  setState(STATE.IDLE);
}

/* ================= ENVOI AU WEBHOOK ================= */
async function sendToWebhook() {
  const text = inputText.value.trim();
  
  if (!text) {
    addLog("‚ö†Ô∏è Aucun texte √† envoyer");
    setState(STATE.IDLE);
    return;
  }
  
  if (text.length < CONFIG.minCharsToSend) {
    addLog(`‚ö†Ô∏è Texte trop court: ${text.length} caract√®res`);
    setState(STATE.IDLE);
    return;
  }
  
  setState(STATE.PROCESSING);
  
  outputText.value = "";
  btnSpeak.disabled = true;
  
  addLog(`üì° Envoi: "${text.substring(0, 50)}..."`);
  
  try {
    const response = await fetch(CONFIG.webhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ chatInput: text })
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const rawResponse = await response.text();
    addLog(`üì• R√©ponse brute: ${rawResponse.substring(0, 100)}...`);
    
    let answer = rawResponse;
    try {
      const parsed = JSON.parse(rawResponse);
      answer = extractOutput(parsed) || rawResponse;
    } catch (e) {
      addLog("‚ö†Ô∏è R√©ponse non-JSON, utilisation brute");
    }
    
    outputText.value = answer;
    btnSpeak.disabled = false;
    
    addLog(`‚úÖ R√©ponse extraite: "${answer.substring(0, 50)}..."`);
    
    speakResponse(answer);
    
  } catch (error) {
    addLog(`‚ùå Erreur r√©seau: ${error.message}`);
    setState(STATE.IDLE);
    
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 2000);
    }
  }
}

/* ================= EXTRACTION DE LA R√âPONSE ================= */
function extractOutput(obj) {
  if (!obj || typeof obj !== "object") return null;
  if (typeof obj.output === "string") return obj.output;
  
  for (const key in obj) {
    const result = extractOutput(obj[key]);
    if (result) return result;
  }
  
  return null;
}

/* ================= SYNTH√àSE VOCALE ================= */
function speakResponse(text) {
  if (!text) {
    addLog("‚ö†Ô∏è Pas de texte √† lire");
    setState(STATE.IDLE);
    return;
  }
  
  setState(STATE.SPEAKING);
  speechSynthesis.cancel();
  
  const utterance = new SpeechSynthesisUtterance(text);
  utterance.lang = CONFIG.lang;
  utterance.rate = 1.0;
  utterance.pitch = 1.0;
  
  utterance.onstart = () => {
    addLog("üîä Lecture TTS d√©marr√©e");
  };
  
  utterance.onend = () => {
    addLog("‚úÖ Lecture TTS termin√©e");
    setState(STATE.IDLE);
    
    if (CONFIG.continuousMode) {
      addLog(`‚è≥ Red√©marrage dans ${CONFIG.restartAfterTtsMs}ms`);
      setTimeout(() => {
        if (currentState === STATE.IDLE) {
          startListening();
        }
      }, CONFIG.restartAfterTtsMs);
    }
  };
  
  utterance.onerror = (event) => {
    addLog(`‚ùå Erreur TTS: ${event.error}`);
    setState(STATE.IDLE);
    
    if (CONFIG.continuousMode) {
      setTimeout(startListening, 2000);
    }
  };
  
  speechSynthesis.speak(utterance);
}

/* ================= BOUTONS UI ================= */
btnMic.onclick = () => {
  addLog("üñ±Ô∏è Clic D√©marrer");
  startListening();
};

btnStop.onclick = () => {
  addLog("üñ±Ô∏è Clic Stop");
  forceStop();
};

btnSend.onclick = () => {
  addLog("üñ±Ô∏è Clic Envoyer manuel");
  sendToWebhook();
};

btnSpeak.onclick = () => {
  addLog("üñ±Ô∏è Clic Relire");
  speakResponse(outputText.value);
};

btnClear.onclick = () => {
  addLog("üñ±Ô∏è Clic Effacer");
  inputText.value = "";
  outputText.value = "";
  rawText.value = "";
  btnSpeak.disabled = true;
  setState(STATE.IDLE);
};

/* ================= INITIALISATION ================= */
if (initSpeechRecognition()) {
  addLog("‚úÖ Jarvis initialis√© avec succ√®s");
  addLog("üí° Clique sur 'D√©marrer' ou dis quelque chose !");
} else {
  addLog("‚ùå Impossible d'initialiser");
}
</script>
</body>
</html>
